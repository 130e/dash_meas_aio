<!doctype html>
<html>

<head>
    <title>dash.js Rocks</title>
    <style>
        video {
            width: 640px;
            height: 360px;
        }
    </style>
</head>

<body>
    <div>
        <video id="videoPlayer" controls></video>
    </div>
    <script type="module">
        // Initialize
        import { MediaPlayer } from '/js/dash.all.debug.js';

        const player = MediaPlayer().create();

        player.initialize(
            document.querySelector('#videoPlayer'),
            'encoded/chunks/manifest.mpd',
            true
        );

        // Dash event metrics for global access
        window.player = player;
        window.dashEventLog = [];

        // Register playback end event for client script
        window.dashPlaybackEnded = false;
        player.on(dashjs.MediaPlayer.events.PLAYBACK_ENDED, function (e) {
            window.dashPlaybackEnded = true;
        });

        // Helper to record events locally
        function recordEvent(name, eventObj) {
            const record = {
                name: name,
                perfTime: performance.now(), // relative to page load
                wallTime: Date.now(), // absolute time in milliseconds since epoch
            };
            // Filter out some large logs
            if (name === "qualityChangeRequested" || name === "qualityChangeRendered") {
                const summary = {
                    isAdaptationSetSwitch: eventObj.isAdaptationSetSwitch,
                    reason: eventObj.reason,
                    type: eventObj.type,
                };
                if (eventObj.newRepresentation) {
                    summary.newRepresentation = {
                        id: eventObj.newRepresentation.id,
                        media: eventObj.newRepresentation.media,
                    };
                }
                if (eventObj.oldRepresentation) {
                    summary.oldRepresentation = {
                        id: eventObj.oldRepresentation.id,
                        media: eventObj.oldRepresentation.media,
                    };
                }
                record.data = summary;
            }
            else if (name === "fragmentLoadingStarted" || name === "fragmentLoadingCompleted" || name === "fragmentLoadingAbandoned") {
                if (eventObj.request) {
                    const summary = {
                        request: {
                            action: eventObj.request.action,
                            index: eventObj.request.index,
                            retryAttempts: eventObj.request.retryAttempts,
                            startTime: eventObj.request.startTime,
                            adaptationIndex: eventObj.request.adaptationIndex,
                        }
                    };
                    if (eventObj.request.representation) {
                        summary.request.representation = {
                            id: eventObj.request.representation.id,
                            media: eventObj.request.representation.media,
                        };
                    }
                    record.data = summary;
                }
                else {
                    record.data = {
                        request: null,
                    };
                }
            }
            else {
                record.data = eventObj;
            }

            window.dashEventLog.push(record);
        }

        // List of dash.js events to monitor
        const ev = dashjs.MediaPlayer.events;

        const eventList = [
            // ev.BUFFER_EMPTY,
            // ev.BUFFER_LOADED,
            ev.BUFFER_LEVEL_STATE_CHANGED,
            ev.BUFFER_LEVEL_UPDATED,

            ev.QUALITY_CHANGE_REQUESTED,
            ev.QUALITY_CHANGE_RENDERED,

            // ev.REPRESENTATION_SWITCH,

            ev.FRAGMENT_LOADING_STARTED,
            ev.FRAGMENT_LOADING_ABANDONED,
            // ev.FRAGMENT_LOADING_PROGRESS,
            ev.FRAGMENT_LOADING_COMPLETED,

            ev.PLAYBACK_STARTED, // at beginning
            ev.PLAYBACK_PAUSED,  // at manual pause
            // ev.PLAYBACK_SEEKED,  // at manual seek
            // ev.PLAYBACK_TIME_UPDATED,
            ev.PLAYBACK_ENDED,   // at end

            ev.PLAYBACK_STALLED, // at browser reports stalled
            ev.PLAYBACK_WAITING, // at insufficient buffer data
            ev.PLAYBACK_PLAYING  // resume after stalling
        ];

        // Register everything
        eventList.forEach(eventType => {
            player.on(eventType, function (e) {
                recordEvent(eventType, e);
            });
        });


    </script>

</body>

</html>